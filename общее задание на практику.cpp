#include <iostream>
#include <cstdlib>  // Для функции rand
#include <ctime>    // Для функции time
#include <cstdlib> // Для использования system("cls")
using namespace std;

/*Функция printArr выводит элементы массива arr размером size на экран, разделяя их пробелами. 
Каждый элемент выводится последовательно с помощью цикла for, который проходит по индексам массива.
Внутри цикла значение элемента arr[i] выводится с использованием cout,
а после окончания цикла выводится символ новой строки (endl), 
чтобы элементы выводились в отдельных строках.*/
void printArr(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

/*Класс Node представляет узел односвязного списка.
Узел содержит данные типа int и указатель next, указывающий на следующий узел списка.
Конструктор класса Node принимает аргумент data,
который инициализирует поле data узла соответствующим значением. 
Поле next инициализируется значением NULL,
чтобы указать, что текущий узел не имеет следующего узла в списке.*/
class Node {
public:
    int data;
    Node* next;

public:
    Node(int data) {
        this->data = data;
        this->next = NULL;
    }
};

/*Класс OneLinkedList представляет собой реализацию односвязного списка.
Он содержит два указателя: head и tail, которые указывают на первый и последний узлы списка соответственно.*/
class OneLinkedList {
public:
    Node* head, * tail;

public:
    /*Конструктор OneLinkedList является конструктором без параметров
    и инициализирует начальные значения указателей head и tail 
    списка значением NULL. Это означает, что при создании объекта класса
    OneLinkedList, список пока не содержит ни одного узла,
    и оба указателя указывают на NULL.*/
    OneLinkedList() {
        this->head = NULL;
        this->tail = NULL;
    }

    /*Деструктор ~OneLinkedList освобождает память, выделенную под узлы списка,
    вызывая функцию clear().*/
    ~OneLinkedList() {
        clear();
    }

    /*Функция clear() очищает список, удаляя все его элементы.
    Она выполняет цикл, пока head не равен NULL,
    и на каждой итерации вызывает функцию pop_front().*/
    void clear() {
        while (head != NULL) {
            pop_front();
        }
    }

    /*Функция pop_front() удаляет первый элемент списка. Вначале она проверяет,
    является ли список пустым, проверяя, равен ли указатель head значению NULL.
    Если список пуст, функция завершается без выполнения дальнейших операций.
    Если в списке содержится только один элемент (то есть head равен tail), то 
    происходит удаление этого элемента. Указатель tail также устанавливается в NULL,
    чтобы указывать на пустой список. В противном случае, функция создает временный указатель node,
    который указывает на первый элемент списка (head). Затем указатель head переносится на следующий
    элемент списка (head = node->next), и элемент, на который указывал node, удаляется с помощью оператора delete.*/
    void pop_front() {
        if (head == NULL) {
            return;
        }
        if (head == tail) {
            delete tail;
            head = tail = NULL;
            return;
        }

        Node* node = head;
        head = node->next;
        delete node;
    }

    /*Функция pop_back() удаляет последний элемент списка.
    Сначала она проверяет, является ли список пустым, проверяя, равен ли указатель tail 
    значению NULL. Если список пуст, функция завершается без выполнения дальнейших операций.
    Если в списке содержится только один элемент (то есть head равен tail), то происходит удаление этого элемента.
    Указатель head также устанавливается в NULL, чтобы указывать на пустой список.
    В противном случае, функция выполняет цикл, ища элемент, предшествующий последнему элементу списка.
    Это делается с помощью временного указателя node, который начинает с head
    и продвигается по списку до тех пор, пока node->next не станет равным tail.
    После выхода из цикла, node указывает на элемент, предшествующий последнему элементу списка.
    Далее происходит удаление последнего элемента. Указатель node->next устанавливается в NULL, 
    чтобы обозначить конец списка. Затем элемент, на который указывал tail, удаляется с помощью оператора delete.
    Потом указатель tail переносится на node, указывая на новый последний элемент списка.*/
    void pop_back() {
        if (tail == NULL) {
            return;
        }
        if (head == tail) {
            delete tail;
            head = tail = NULL;
            return;
        }

        Node* node = head;
        for (; node->next != tail; node = node->next);
        node->next = NULL;
        delete tail;
        tail = node;
    }

    /*Функция push_front() добавляет элемент в начало списка.
    Сначала она создает новый узел с переданным значением data с помощью оператора new.
    Затем новый узел node добавляется в начало списка путем присваивания указателю node->next значения указателя head.
    Затем указатель head обновляется, чтобы указывать на новый узел node, делая его новой головой списка.
    Если список был пустым до добавления нового узла, то указатель tail также обновляется, чтобы указывать на новый узел node, 
    так как теперь это будет единственный элемент списка.*/
    void push_front(int data) {
        Node* node = new Node(data);
        node->next = head;
        head = node;
        if (tail == NULL) {
            tail = node;
        }
    }

    /*Функция push_back() добавляет элемент в конец списка.
    Сначала она создает новый узел с переданным значением data с помощью оператора new.
    Затем происходит проверка состояния списка.
    Если список пустой (head == NULL), то указатель head обновляется,
    чтобы указывать на новый узел node, так как он будет являться единственным элементом списка.
    Если список не пустой (tail != NULL), то указатель tail->next обновляется, 
    чтобы указывать на новый узел node. Это связывает новый узел с последним узлом списка.
    Затем указатель tail обновляется, чтобы указывать на новый узел node, 
    так как он становится новым последним элементом списка.*/
    void push_back(int data) {
        Node* node = new Node(data);
        if (head == NULL) {
            head = node;
        }
        if (tail != NULL) {
            tail->next = node;
        }
        tail = node;
    }

    /*Функция getAt() возвращает указатель на узел списка по заданному индексу k.
    Сначала функция проверяет, что значение индекса k является неотрицательным числом. Если k отрицательно,
    функция возвращает NULL, указывая на некорректный индекс.
    Затем создается указатель node, который инициализируется значением указателя head, указывающего на первый элемент списка.
    Далее выполняется цикл, который итерируется по узлам списка до тех пор,
    пока не будет достигнут заданный индекс k или конец списка.
    Внутри цикла указатель node переходит к следующему узлу node->next, а переменная n увеличивается на 1.
    Если после выполнения цикла значение n равно k, это означает, что был найден узел с заданным индексом.
    В этом случае функция возвращает указатель на найденный узел node.
    Если значение n не равно k, это означает, что достигнут конец списка
    и заданный индекс выходит за его пределы.
    В этом случае функция возвращает NULL, указывая на некорректный индекс.*/
    Node* getAt(int k) {
        if (k < 0) {
            return NULL;
        }

        Node* node = head;
        int n = 0;
        while (node && n != k && node->next) {
            node = node->next;
            n++;
        }

        if (n == k) {
            return node;
        }
        else {
            return NULL;
        }
    }

    /*Функция insert() вставляет новый узел со значением data на заданную позицию k в связном списке.
    Сначала функция проверяет, что значение индекса k является неотрицательным числом.
    Если k отрицательно, функция завершает свою работу, не выполняя никаких операций.
    Затем проверяется специальный случай, когда k равно 0. В этом случае вызывается функция push_front(data),
    которая добавляет новый узел в начало списка, и вставка завершается.
    Если k не равно 0, то функция пытается получить указатель на узел, предшествующий позиции k. Для этого вызывается функция getAt(k - 1),
    которая возвращает указатель на узел с индексом k - 1. Если указатель prev равен NULL, это означает,
    что индекс k - 1 выходит за пределы списка, и вставка не может быть выполнена.
    Если указатель prev не равен NULL, то получается указатель next, указывающий на узел, следующий за prev.
    Затем создается новый узел node со значением data. Устанавливаются связи между узлами: prev->next указывает на новый узел node,
    а node->next указывает на узел next. Если next равен NULL, то это означает, что node становится последним элементом списка,
    поэтому обновляется значение указателя tail на node.*/
    void insert(int k, int data) {
        if (k < 0) {
            return;
        }

        if (k == 0) {
            push_front(data);
            return;
        }

        Node* prev = getAt(k - 1);
        if (prev == NULL) {
            return;
        }

        Node* next = prev->next;
        Node* node = new Node(data);

        prev->next = node;
        node->next = next;
        if (next == NULL) {
            tail = node;
        }
    }

    /*Функция erase(int k) используется для удаления узла из связного списка по указанному индексу k.
    Сначала функция проверяет, что значение индекса k является неотрицательным числом.
    Если k отрицательно, функция завершает свою работу, не выполняя никаких операций.
    Затем функция проверяет, если индекс k равен 0, то вызывается функция pop_front(), 
    которая удаляет первый узел списка (узел, на который указывает head), и затем функция завершается.
    В противном случае, функция находит узел, предшествующий узлу с индексом k (узел на индексе k - 1) с помощью функции getAt(k - 1).
    Если полученный узел равен NULL, то функция завершает свою работу, не выполняя никаких операций.
    Если все проверки пройдены успешно, функция получает ссылку на удаляемый узел (node) и ссылку на узел, следующий за удаляемым узлом (right).
    Затем функция перенаправляет указатель next узла left на узел right, пропуская удаляемый узел node.
    Если удаляемый узел node является последним узлом списка (узелом, на который указывает tail), то tail перенаправляется на узел left,
    чтобы указывать на новый последний узел списка. Наконец, функция освобождает память, занимаемую удаляемым узлом node, и завершается.*/
    void erase(int k) {
        if (k < 0) {
            return;
        }
        if (k == 0) {
            pop_front();
            return;
        }

        Node* left = getAt(k - 1);
        Node* node = left->next;
        if (node == NULL) {
            return;
        }
        Node* right = node->next;

        left->next = right;
        if (node == tail) {
            tail = left;
        }
        delete node;
    }

    /*Функция remove(int data) используется для удаления всех узлов в связном списке, которые содержат заданное значение data.
    Вначале функция инициализирует указатель node для перебора узлов списка, начиная с head, и указатель prev для хранения предыдущего узла.
    Затем функция выполняет цикл, пока указатель node не станет равным NULL. В каждой итерации цикла проверяется значение data текущего узла node.
    Если значение data совпадает с заданным значением data, то выполняются соответствующие операции удаления.
    Если узел node является первым узлом списка (узлом, на который указывает head), то вызывается функция pop_front(), которая удаляет первый узел.
    Если узел node является последним узлом списка (узлом, на который указывает tail), то вызывается функция pop_back(), которая удаляет последний узел.
    В противном случае, указатель next у предыдущего узла prev перенаправляется на узел, следующий за удаляемым узлом node, 
    и память, занимаемая узлом node, освобождается с помощью оператора delete.
    Цикл перебора продолжается до тех пор, пока не будут пройдены все узлы списка или будет найден первый узел с заданным значением data.
    Если значение data не найдено в списке, то функция завершается без выполнения операций удаления.*/
    void remove(int data) {
        Node* node = head;
        Node* prev = NULL;

        while (node != NULL) {
            if (node->data == data) {
                if (prev == NULL) {
                    pop_front();
                }
                else if (node == tail) {
                    pop_back();
                }
                else {
                    prev->next = node->next;
                    delete node;
                }
                return;
            }
            prev = node;
            node = node->next;
        }
    }

    /*Функция find(int data) используется для поиска первого узла в связном списке, который содержит заданное значение data.
    Функция возвращает индекс этого узла в списке или -1, если значение не найдено.
    Вначале функция инициализирует указатель node для перебора узлов списка, начиная с head, и переменную index для хранения текущего индекса узла.
    Затем функция выполняет цикл, пока указатель node не станет равным NULL. В каждой итерации цикла проверяется значение data текущего узла node
    Если значение data совпадает с заданным значением data, то функция возвращает текущий индекс index.
    Если значение data не совпадает, то указатель node перенаправляется на следующий узел с помощью оператора node = node->next,
    и индекс index увеличивается на 1. Если после перебора всех узлов список не содержит узла с заданным значением data,
    то функция возвращает -1.*/
    int find(int data) {
        Node* node = head;
        int index = 0;

        while (node != NULL) {
            if (node->data == data) {
                return index;
            }
            node = node->next;
            index++;
        }

        return -1;
    }

    /*Функция printList() используется для печати содержимого связного списка. Она проходит по каждому узлу списка, 
    начиная с head, и выводит значение data каждого узла на консоль, разделенное пробелом.
    Вначале функция инициализирует указатель node для перебора узлов списка, начиная с head.
    Затем функция выполняет цикл, пока указатель node не станет равным NULL.*/
    void printList() {
        Node* node = head;
        while (node != NULL) {
            cout << node->data << " ";
            node = node->next;
        }
        cout << endl;
    }
};

int main()
{
    setlocale(LC_ALL, "rus"); // устанавливает локаль программы на русскую, чтобы поддерживать русский язык ввода-вывода

    OneLinkedList lst; // создает объект класса OneLinkedList с именем lst

    int choice;
    bool exit = false;

    while (!exit) {
        cout << "Выберите операцию:" << endl;
        cout << "1. Добавить элемент в начало списка" << endl;
        cout << "2. Добавить элемент в конец списка" << endl;
        cout << "3. Удалить первый элемент списка" << endl;
        cout << "4. Удалить последний элемент списка" << endl;
        cout << "5. Вывести список" << endl;
        cout << "6. Очистить список" << endl;
        cout << "7. Удалить элемент по значению" << endl;
        cout << "8. Удалить элемент по номеру" << endl;
        cout << "9. Найти номер элемента" << endl;
        cout << "10. Добавить элемент в определенную позицию" << endl;
        cout << "11. Построить список из массива" << endl;
        cout << "12. Создание списка с вводом элементов с клавиатуры" << endl;
        cout << "13. Выход" << endl;
        cout << "Ваш выбор: ";
        cin >> choice;

        /*switch (choice) является конструкцией, которая позволяет выполнить 
        различные действия в зависимости от значения переменной choice. Здесь choice представляет выбор операции, 
        сделанный пользователем в меню. Код внутри блока switch содержит несколько case, каждый из которых соответствует 
        определенной операции. Когда значение choice совпадает с значением в каком-либо case, 
        код выполняет соответствующие действия внутри этого case. Если ни одно из значений choice не совпадает с case, 
        выполнение переходит к блоку default, который определяет действия при неправильном выборе.*/
        switch (choice) {
            case 1: {
                system("cls");
                int data;
                cout << "Введите элемент для добавления в начало списка: ";
                cin >> data;
                lst.push_front(data);
                cout << "Элемент успешно добавлен в начало списка." << endl << endl;
                continue;;
            }
            case 2: {
                system("cls");
                int data;
                cout << "Введите элемент для добавления в конец списка: ";
                cin >> data;
                lst.push_back(data);
                cout << "Элемент успешно добавлен в конец списка." << endl << endl;
                continue;;
            }
            case 3: {
                system("cls");
                lst.pop_front();
                cout << "Первый элемент списка успешно удален." << endl << endl;
                continue;;
            }
            case 4: {
                system("cls");
                lst.pop_back();
                cout << "Последний элемент списка успешно удален." << endl << endl;
                continue;;
            }
            case 5: {
                system("cls");
                cout << "Список: ";
                lst.printList();
                cout << endl;
                continue;;
            }
            case 6: {
                system("cls");
                lst.clear();
                cout << "Список успешно очищен." << endl << endl;
                continue;;
            }
            case 7: {
                system("cls");
                int data;
                cout << "Введите значение элемента для удаления: ";
                cin >> data;
                lst.remove(data);
                cout << "Элемент успешно удален." << endl << endl;
                continue;;
            }
            case 8: {
                system("cls");
                int index;
                cout << "Введите номер элемента для удаления: ";
                cin >> index;
                lst.erase(index);
                cout << "Элемент успешно удален." << endl << endl;
                continue;;
            }
            case 9: {
                system("cls");
                int data;
                cout << "Введите значение элемента для поиска его номера: ";
                cin >> data;
                int index = lst.find(data);
                if (index != -1) {
                    cout << "Номер элемента: " << index << endl << endl;
                }
                else {
                    cout << "Элемент не найден." << endl << endl;
                }
                continue;;
            }
            case 10: {
                system("cls");
                int index, data;
                cout << "Введите номер позиции для вставки элемента: ";
                cin >> index;
                cout << "Введите значение элемента: ";
                cin >> data;
                lst.insert(index, data);
                cout << "Элемент успешно добавлен в позицию " << index << "." << endl << endl;
                continue;;
            }
            case 11: {
                system("cls");
                int size;
                cout << "Введите размер массива: ";
                cin >> size;
                cout << endl;
                int* arr = new int[size];

                srand(time(NULL));

                for (int i = 0; i < size; i++) {
                    arr[i] = rand();
                }

                cout << "Ваш массив: " << endl;
                printArr(arr, size);
                cout << endl;

                for (int i = 0; i < size; i++) {
                    lst.push_back(arr[i]);
                }

                cout << "Ваш односвязный список: " << endl;
                lst.printList();

                delete[] arr;

                cout << endl << endl;
                continue;
            }
            case 12: {
                system("cls");
                int size;
                cout << "Введите количество элементов списка: ";
                cin >> size;
                cout << endl;

                cout << "Введите элементы списка: " << endl;
                for (int i = 0; i < size; i++) {
                    int data;
                    cout << "Элемент " << i + 1 << ": ";
                    cin >> data;
                    lst.push_back(data);
                }

                cout << "Односвязный список успешно создан." << endl << endl;
                continue;
            }
            case 13: {
                exit = true;
                break;
            }
            default: {
                cout << "Неверный выбор. Попробуйте снова." << endl << endl;
                break;
            }
        }
    }

    cout << endl << endl << endl << endl << endl;

    return 0;
}